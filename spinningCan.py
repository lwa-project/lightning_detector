#!/usr/bin/env python
# -*- coding: utf-8 -*-
# generated by wxGlade 0.3.1 on Fri Oct 03 23:23:45 2003

"""
spinningCan.py - Python script (based on the pySerial/wxTerminal.py example) for 
reading in serial port data from a Boltek EFM-100 atmospheric electric field 
monitor and printing out the electric field and it change.
"""

import wx
import wxSerialConfigDialog
import serial
import threading

import re
from time import sleep
from datetime import datetime

# Electric field and lightning warning levels
HIGH_FIELD = 5.0
VERY_HIGH_FIELD = 7.0
LIGHTNING_MIN_FIELD_CHANGE = 0.05

# Electric field string regular expression
fieldRE = re.compile('\$(?P<field>[-+]\d{2}\.\d{2}),(?P<status>\d)\*(?P<checksum>[0-9A-F]{2})')

def computeChecksum(text):
	"""
	Compute the checksum for the output string using the first 10 characters.
	Return the checksum as a string for easy comparision in parseField.
	"""
	
	cSum = 0
	for c in text[:10]:
		cSum += ord(c)
		cSum %= 256
		
	return "%2X" % cSum

def parseField(text):
	"""
	Parse the output string with the format:
	  $<p><ee.ee>,<f>*<cs><cr><lf>
	  
	  <p> - polarity of electric field + or -
	  <ee.ee> - electric field level 00.00 to 20.00
	  <f> - fault 0: Normal, 1: Rotor Fault
	  <cs> - checksum in hex 00 to FF
	  <cr> - carriage return
	  <lf> - line feed
	  
	And return a three-element tuple of the field string, status code, and 
	a boolean of whether or not the data are valid.
	"""

	mtch = fieldRE.match(text)

	try:
		field = float(mtch.group('field'))
		status = int(mtch.group('status'))
		valid = True if mtch.group('checksum') == computeChecksum(text) else False
	except:
		field = 0.0
		status = 2
		valid = False
		
	return field, status, valid


def highField(field):
	"""
	Given an electric field value, compare it against HIGH_FIELD and return True
	if it *is* a high field.
	"""
	
	if abs(field) > HIGH_FIELD:
		return True
	else:
		return False


def veryHighField(field):
	"""
	Given an electric field value, compare it against HIGH_FIELD and return True
	if it *is* a high field.
	"""
	
	if abs(field) > VERY_HIGH_FIELD:
		return True
	else:
		return False

def lightning(deltaField):
	"""
	Given a change in the electric field, compare it with LIGHTNING_MIN_FIELD_CHANGE
	and see if it could be related to lightning.  If so, calculate a distance using
	a 10 kV/m field change for lightning at 5 km.
	"""
	
	if abs(deltaField) > LIGHTNING_MIN_FIELD_CHANGE:
		distance = (10.0/abs(deltaField))**(1/3.) * 5
		return True, distance
	else:
		return False, 100.0


class PlotPanel(wx.Panel):
	"""
	The PlotPanel has a Figure and a Canvas. OnSize events simply set a 
	flag, and the actual resizing of the figure is triggered by an Idle event.
	
	From: http://www.scipy.org/Matplotlib_figure_in_a_wx_panel
	"""
	
	def __init__(self, parent, color=None, dpi=None, **kwargs):
		from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg
		from matplotlib.figure import Figure

		# initialize Panel
		if 'id' not in kwargs.keys():
			kwargs['id'] = wx.ID_ANY
		if 'style' not in kwargs.keys():
			kwargs['style'] = wx.NO_FULL_REPAINT_ON_RESIZE
		wx.Panel.__init__(self, parent, **kwargs)

		# initialize matplotlib stuff
		self.figure = Figure(None, dpi)
		self.canvas = FigureCanvasWxAgg(self, -1, self.figure)
		self.SetColor(color)

		self._SetSize()
		self.draw()

		self._resizeflag = False

		self.Bind(wx.EVT_IDLE, self._onIdle)
		self.Bind(wx.EVT_SIZE, self._onSize)

	def SetColor( self, rgbtuple=None ):
		"""
		Set figure and canvas colours to be the same.
		"""
		
		if rgbtuple is None:
			rgbtuple = wx.SystemSettings.GetColour( wx.SYS_COLOUR_BTNFACE ).Get()
		clr = [c/255. for c in rgbtuple]
		self.figure.set_facecolor(clr)
		self.figure.set_edgecolor(clr)
		self.canvas.SetBackgroundColour(wx.Colour(*rgbtuple))

	def _onSize(self, event):
		self._resizeflag = True

	def _onIdle(self, evt):
		if self._resizeflag:
			self._resizeflag = False
			self._SetSize()

	def _SetSize(self):
		pixels = (546,446) #tuple(self.parent.GetClientSize())
		self.SetSize(pixels)
		self.canvas.SetSize(pixels)
		self.figure.set_size_inches(float( pixels[0] )/self.figure.get_dpi(), float( pixels[1] )/self.figure.get_dpi())

	def draw(self):
		pass # abstract, to be overridden by child classes


class EFPanel(PlotPanel):
	def __init__(self, parent, time=[], field=[], dfield=[], **kwargs):
		self.parent = parent
		self.time = time
		self.field = field
		self.dfield = dfield
		self.nPts = 0
		
		# initiate plotter
		PlotPanel.__init__( self, parent, **kwargs )
		self.SetColor( (255,255,255) )

	def draw(self):
		"""
		Draw data.
		"""
		
		from pylab import date2num
		from matplotlib.dates import AutoDateLocator, MinuteLocator, SecondLocator
		
		if not hasattr( self, 'subplot' ):
			self.ax1 = self.figure.add_subplot( 111 )

		if len(self.field) < 3:
			pass
		else:
			self.ax1.cla()
			self.ax1.plot_date(date2num(self.time), self.field,  color='g', linestyle='-',  marker=' ')
			self.ax1.plot_date(date2num(self.time), self.dfield, color='b', linestyle='--', marker=' ')
			
			self.ax1.set_xlabel('Time')
			self.ax1.set_ylabel('E-Field [kV/m]')
			self.locator = SecondLocator(bysecond=range(0,60,30))
			self.ax1.xaxis.set_major_locator(self.locator)
			self.figure.autofmt_xdate()


#----------------------------------------------------------------------
# Create an own event type, so that GUI updates can be delegated
# this is required as on some platforms only the main thread can
# access the GUI without crashing. wxMutexGuiEnter/wxMutexGuiLeave
# could be used too, but an event is more elegant.

SERIALRX = wx.NewEventType()
# bind to serial data receive events
EVT_SERIALRX = wx.PyEventBinder(SERIALRX, 0)

class SerialRxEvent(wx.PyCommandEvent):
	eventType = SERIALRX
	def __init__(self, windowID, data):
		wx.PyCommandEvent.__init__(self, self.eventType, windowID)
		self.data = data

	def Clone(self):
		self.__class__(self.GetId(), self.data)

#----------------------------------------------------------------------

ID_CLEAR        = wx.NewId()
ID_SAVEAS       = wx.NewId()
ID_SETTINGS     = wx.NewId()
ID_TERM         = wx.NewId()
ID_EXIT         = wx.NewId()

NEWLINE_CR      = 0
NEWLINE_LF      = 1
NEWLINE_CRLF    = 2

class TerminalSetup:
	"""
	Placeholder for various terminal settings. Used to pass the options to 
	the TerminalSettingsDialog.
	"""
	
	def __init__(self):
		self.echo = False
		self.unprintable = False
		self.newline = NEWLINE_CRLF


class TerminalSettingsDialog(wx.Dialog):
	"""
	Simple dialog with common terminal settings like echo, newline mode.
	"""
	
	def __init__(self, *args, **kwds):
		self.settings = kwds['settings']
		del kwds['settings']
		# begin wxGlade: TerminalSettingsDialog.__init__
		kwds["style"] = wx.DEFAULT_DIALOG_STYLE
		wx.Dialog.__init__(self, *args, **kwds)
		self.checkbox_echo = wx.CheckBox(self, -1, "Local Echo")
		self.checkbox_unprintable = wx.CheckBox(self, -1, "Show unprintable characters")
		self.radio_box_newline = wx.RadioBox(self, -1, "Newline Handling", choices=["CR only", "LF only", "CR+LF"], majorDimension=0, style=wx.RA_SPECIFY_ROWS)
		self.button_ok = wx.Button(self, -1, "OK")
		self.button_cancel = wx.Button(self, -1, "Cancel")

		self.__set_properties()
		self.__do_layout()
		# end wxGlade
		self.__attach_events()
		self.checkbox_echo.SetValue(self.settings.echo)
		self.checkbox_unprintable.SetValue(self.settings.unprintable)
		self.radio_box_newline.SetSelection(self.settings.newline)

	def __set_properties(self):
		# begin wxGlade: TerminalSettingsDialog.__set_properties
		self.SetTitle("Terminal Settings")
		self.radio_box_newline.SetSelection(0)
		self.button_ok.SetDefault()
		# end wxGlade

	def __do_layout(self):
		# begin wxGlade: TerminalSettingsDialog.__do_layout
		sizer_2 = wx.BoxSizer(wx.VERTICAL)
		sizer_3 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_4 = wx.StaticBoxSizer(wx.StaticBox(self, -1, "Input/Output"), wx.VERTICAL)
		sizer_4.Add(self.checkbox_echo, 0, wx.ALL, 4)
		sizer_4.Add(self.checkbox_unprintable, 0, wx.ALL, 4)
		sizer_4.Add(self.radio_box_newline, 0, 0, 0)
		sizer_2.Add(sizer_4, 0, wx.EXPAND, 0)
		sizer_3.Add(self.button_ok, 0, 0, 0)
		sizer_3.Add(self.button_cancel, 0, 0, 0)
		sizer_2.Add(sizer_3, 0, wx.ALL|wx.ALIGN_RIGHT, 4)
		self.SetAutoLayout(1)
		self.SetSizer(sizer_2)
		sizer_2.Fit(self)
		sizer_2.SetSizeHints(self)
		self.Layout()
		# end wxGlade

	def __attach_events(self):
		self.Bind(wx.EVT_BUTTON, self.OnOK, id = self.button_ok.GetId())
		self.Bind(wx.EVT_BUTTON, self.OnCancel, id = self.button_cancel.GetId())
	
	def OnOK(self, events):
		"""
		Update data wil new values and close dialog.
		"""
		
		self.settings.echo = self.checkbox_echo.GetValue()
		self.settings.unprintable = self.checkbox_unprintable.GetValue()
		self.settings.newline = self.radio_box_newline.GetSelection()
		self.EndModal(wx.ID_OK)
	
	def OnCancel(self, events):
		"""
		Do not update data but close dialog.
		"""
		
		self.EndModal(wx.ID_CANCEL)

# end of class TerminalSettingsDialog


class TerminalFrame(wx.Frame):
	"""
	Simple terminal program for wxPython.
	"""
	
	def __init__(self, *args, **kwds):
		self.serial = serial.Serial()
		self.serial.timeout = 0.5   #make sure that the alive event can be checked from time to time
		self.settings = TerminalSetup() #placeholder for the settings
		self.thread = None
		self.alive = threading.Event()               
		# begin wxGlade: TerminalFrame.__init__
		kwds["style"] = wx.DEFAULT_FRAME_STYLE
		wx.Frame.__init__(self, *args, **kwds)
		self.epanel = EFPanel(self)
		self.text_ctrl_output = wx.TextCtrl(self, -1, "", style=wx.TE_MULTILINE|wx.TE_READONLY)
		
		# Menu Bar
		self.frame_terminal_menubar = wx.MenuBar()
		self.SetMenuBar(self.frame_terminal_menubar)
		wxglade_tmp_menu = wx.Menu()
		wxglade_tmp_menu.Append(ID_CLEAR, "&Clear", "", wx.ITEM_NORMAL)
		wxglade_tmp_menu.Append(ID_SAVEAS, "&Save Text As...", "", wx.ITEM_NORMAL)
		wxglade_tmp_menu.AppendSeparator()
		wxglade_tmp_menu.Append(ID_SETTINGS, "&Port Settings...", "", wx.ITEM_NORMAL)
		wxglade_tmp_menu.Append(ID_TERM, "&Terminal Settings...", "", wx.ITEM_NORMAL)
		wxglade_tmp_menu.AppendSeparator()
		wxglade_tmp_menu.Append(ID_EXIT, "&Exit", "", wx.ITEM_NORMAL)
		self.frame_terminal_menubar.Append(wxglade_tmp_menu, "&File")
		# Menu Bar end

		self.__set_properties()
		self.__do_layout()
		# end wxGlade
		self.__attach_events()          #register events
		self.OnPortSettings(None)       #call setup dialog on startup, opens port
		if not self.alive.isSet():
			self.Close()

	def StartThread(self):
		"""
		Start the receiver thread
		"""        
		
		self.thread = threading.Thread(target=self.ComPortThread)
		self.thread.setDaemon(1)
		self.alive.set()
		self.thread.start()

	def StopThread(self):
		"""
		Stop the receiver thread, wait util it's finished.
		"""
		
		if self.thread is not None:
			self.alive.clear()          #clear alive event for thread
			self.thread.join()          #wait until thread has finished
			self.thread = None
		
	def __set_properties(self):
		# begin wxGlade: TerminalFrame.__set_properties
		self.SetTitle("Serial Terminal")
		self.SetSize((546, 910))
		# end wxGlade

	def __do_layout(self):
		# begin wxGlade: TerminalFrame.__do_layout
		sizer_1 = wx.BoxSizer(wx.VERTICAL)
		sizer_1.Add(self.epanel, 1, wx.EXPAND, 1)
		sizer_1.Add(self.text_ctrl_output, 1, wx.EXPAND, 1)
		self.SetAutoLayout(1)
		self.SetSizer(sizer_1)
		self.Layout()
		# end wxGlade

	def __attach_events(self):
		#register events at the controls
		self.Bind(wx.EVT_MENU, self.OnClear, id = ID_CLEAR)
		self.Bind(wx.EVT_MENU, self.OnSaveAs, id = ID_SAVEAS)
		self.Bind(wx.EVT_MENU, self.OnExit, id = ID_EXIT)
		self.Bind(wx.EVT_MENU, self.OnPortSettings, id = ID_SETTINGS)
		self.Bind(wx.EVT_MENU, self.OnTermSettings, id = ID_TERM)      
		self.Bind(EVT_SERIALRX, self.OnSerialRead)
		self.Bind(wx.EVT_CLOSE, self.OnClose)

	def OnExit(self, event):
		"""
		Menu point Exit
		"""
		
		self.Close()

	def OnClose(self, event):
		"""
		Called on application shutdown.
		"""
		
		self.StopThread()               #stop reader thread
		self.serial.close()             #cleanup
		self.Destroy()                  #close windows, exit app

	def OnSaveAs(self, event):
		"""
		Save contents of output window.
		"""
		
		filename = None
		dlg = wx.FileDialog(None, "Save Text As...", ".", "", "Text File|*.txt|All Files|*",  wx.SAVE)
		if dlg.ShowModal() ==  wx.ID_OK:
			filename = dlg.GetPath()
		dlg.Destroy()
		
		if filename is not None:
			f = file(filename, 'w')
			text = self.text_ctrl_output.GetValue()
			if type(text) == unicode:
				text = text.encode("latin1")    #hm, is that a good asumption?
			f.write(text)
			f.close()
	
	def OnClear(self, event):
		"""
		Clear contents of output window.
		"""
		
		self.text_ctrl_output.Clear()
    
	def OnPortSettings(self, event=None):
		"""
		Show the portsettings dialog. The reader thread is stopped for the 
		settings change.
		"""
		
		if event is not None:           #will be none when called on startup
			self.StopThread()
			self.serial.close()
		ok = False
		while not ok:
			dialog_serial_cfg = wxSerialConfigDialog.SerialConfigDialog(None, -1, "",
				show=wxSerialConfigDialog.SHOW_BAUDRATE|wxSerialConfigDialog.SHOW_FORMAT|wxSerialConfigDialog.SHOW_FLOW,
				serial=self.serial
			)
			result = dialog_serial_cfg.ShowModal()
			dialog_serial_cfg.Destroy()
			#open port if not called on startup, open it on startup and OK too
			if result == wx.ID_OK or event is not None:
				try:
					self.serial.open()
				except serial.SerialException, e:
					dlg = wx.MessageDialog(None, str(e), "Serial Port Error", wx.OK | wx.ICON_ERROR)
					dlg.ShowModal()
					dlg.Destroy()
				else:
					self.StartThread()
					self.SetTitle("EFM-100 Lightning Detector on %s" % self.serial.portstr)
					ok = True
			else:
				#on startup, dialog aborted
				self.alive.clear()
				ok = True
	
	def OnTermSettings(self, event):
		"""
		Menu point Terminal Settings. Show the settings dialog with the current 
		terminal settings.
		"""
		
		dialog = TerminalSettingsDialog(None, -1, "", settings=self.settings)
		result = dialog.ShowModal()
		dialog.Destroy()

	def OnSerialRead(self, event):
		"""
		Handle input from the serial port.
		"""
		
		text = event.data
		if self.settings.unprintable:
			text = ''.join([(c >= ' ') and c or '<%d>' % ord(c)  for c in text])
		self.text_ctrl_output.AppendText(text)

	def ComPortThread(self):
		"""
		Thread that handles the incomming traffic. Does the basic input 
		transformation (newlines) and generates an SerialRxEvent.
		"""
		
		lastField = 0.0
		text = self.serial.read(1)
		while text != '$':
			text = self.serial.read(1)
		print "INFO: Data aligned"
	
		c = 0
		avgField = 0
		avgDField = 0
		while self.alive.isSet():               #loop while alive event is true
			if text:                            #check if not timeout
				n = 13
				#sleep(0.05)
				#n = self.serial.inWaiting()     #look if there is more to read
				if n:
					text = text + self.serial.read(n) #get it
				#newline transformation
				if self.settings.newline == NEWLINE_CR:
					text = text.replace('\r', '\n')
				elif self.settings.newline == NEWLINE_LF:
					pass
				elif self.settings.newline == NEWLINE_CRLF:
					text = text.replace('\r\n', '\n')
					
				# Parse the string and extract the various bits that we are
				# interested in using parseField
				f, s, v = parseField(text)
				hF = highField(f)
				vF = veryHighField(f)
				dF = f-lastField
				l,d = lightning(dF)
				lastField = f
				
				avgField += f
				avgDField += dF
				c += 1
				if c is 20:
					avgField /= c
					avgDField /= c
					self.epanel.time.append(datetime.now())
					self.epanel.field.append(avgField)
					self.epanel.dfield.append(avgDField)
					if len(self.epanel.field) > 120:
						self.epanel.time  = self.epanel.time[-121:]
						self.epanel.field = self.epanel.field[-121:]
						self.epanel.dfield = self.epanel.dfield[-121:]
					self.epanel.draw()
					
					avgField = 0.0
					avgDField = 0.0
					c = 0
					
				text = ''
				if veryHighField(f):
					text += '%s -> very high field\n' % datetime.now()
					print "WARNING: very high field"
				elif highField(f):
					text += '%s -> high field\n' % datetime.now()
					print "WARNING: high field"
				else:
					pass
				if l:
					text += '%s -> lightning at %i km\n' % (datetime.now(), d)
					print "LIGHTNING: %.1f km" % d
				
				# Create the SerialRxEvent so that the screen is updated
				if text != '':
					text += 'Current field: %.2f kV/m, latest change %.2f kV/m\n' % (f, dF)
					event = SerialRxEvent(self.GetId(), text)
					self.GetEventHandler().AddPendingEvent(event)
			
			# This is a little backwards here.  Because we have the "alignment
			# loop" before the main reading loop.
			text = self.serial.read(1)          #read one, with timout
            
# end of class TerminalFrame


class MyApp(wx.App):
	def OnInit(self):
		wx.InitAllImageHandlers()
		frame_terminal = TerminalFrame(None, -1, "")
		self.SetTopWindow(frame_terminal)
		frame_terminal.Show(1)
		return 1

# end of class MyApp

if __name__ == "__main__":
	app = MyApp(0)
	app.MainLoop()
